//----------------------------------------------------------------
//        * Напишите метод, который добавляет 1 млн элементов
//        в ArrayList и LinkedList.
//        Напишите метод, который выбирает из заполненного
//        списка элемент наугад
//        100 000. Замерьте время, которое потрачено на это.
//        Сравните результаты, предположите почему они именно такие.
//
//
//------------------------------------------------------------

package Million;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class MainLists {
    public static void main(String[] args) {

        //Результат ArrayList - заполнение(34 мс) + выбор случайного элемента(11 мс) = 45 мс(1000 000 элем - 100 000 раз)
        //Результат LinkedList - заполнение(298 мс) + выбор случайного элемента(11 мс) = 22509 мс(1000 000 элем - 10 000 раз)
        //Если апроксимировать для случая 100.000 раз, то разница составит примерно в 5002 раз

        List<Object> myArrList = new ArrayList<>();
        List<Object> myLinkList = new LinkedList<>();

        long start = System.currentTimeMillis();

        // myArrList=ListMethods.fillList((ArrayList<Object>) myArrList,1000000);
        myLinkList = ListMethods.fillList((LinkedList<Object>) myLinkList, 1000000);

        //ListMethods.getRandom((ArrayList<Object>)myArrList,100000);
        ListMethods.getRandom((LinkedList<Object>) myLinkList, 10000);

        long finish = System.currentTimeMillis();
        long elapsed = finish - start;
        System.out.println("Прошло времени, мс: " + elapsed);
    }
}
//Связано с тем как расположены элементы в памяти
//Доступ до элементов в ArrayList происходит гораздо быстрее
//ArrayList устроен по принципу внутреннего массива, размер которого меняется по нашей надобности
//Доступ до элемента в ArrayList не требует проверки последовательности узлов. Поскольку узлов не существует.
//Доступ в LinkedList происходит существенно медленее, поскольку устроен по принципу связанных последовательно друг с другом узлов приходится каждый раз проходить
// все узлы до искомого
//Каждый узел в линкедЛист связан как с предыдущим так и со следуюзщим. Ситуация осложняется когда элемент находится где-то посредине всего массива
//LinkedList обязан пройти все узлы до искомого элемента, если идет речь о начале и конце - то здесь скорость будет по-лучше.
// Чем если элемент находится где-то в отдалении от концов. Чем меньше узлов нужно пройти от концов LinkedList - тем быстрее свершится доступ до искомого элемента